# Episode Six: 把任意图片URL转成Data格式（仅V3版本）

这个demo的目标是做一个浏览器扩展：右键点击网页上的图片时，会弹出菜单；点击菜单后，图片会被处理（比如像素化）、转成Data URI格式，最后替换掉网页上原来的图片，让你立刻看到效果。下面只讲Manifest V3（简称V3）版本的实现。


## 一、V3遇到的核心问题
V3的`background.js`是运行在「Service Worker」环境里的，这个环境没有`document`对象——这就导致两个关键问题：
1. 没法像V2那样用`document.createElement`创建`canvas`（用来处理图片）或`img`（用来加载图片）元素；
2. 想用`fetch` API加载图片，但它受跨域限制，大部分网页的图片都加载不了。


## 二、V3解决方案：用iframe突破限制
扩展里的iframe有两个优势：一是不受网页本身的限制，二是有权限加载各种图片。所以V3的核心思路是：用一个隐藏的iframe来处理图片（创建canvas、加载图片、转换格式），再通过消息传递把处理好的图片数据传回去。


## 三、V3各文件功能详解
下面按文件类型，讲每个文件的作用和关键代码（代码已简化，重点看逻辑）。

### 1. 配置文件：manifest.json
主要是给扩展加「网页可访问资源」的权限，让iframe能被正常加载。
```json
{
  // 其他基础配置（如名称、版本）省略
  "web_accessible_resources": ["/html/scrape.html"] // 允许网页访问扩展里的scrape.html（iframe页面）
}
```


### 2. iframe相关文件：负责处理图片
iframe是V3的核心，用来解决“没法创建canvas/img”的问题，相关文件有2个：

#### （1）scrape.html：iframe的页面结构
特别简单，就是一个空页面，只加载处理逻辑的js文件：
```html
<!DOCTYPE html>
<html>
  <head>
    <title>处理图片</title>
    <meta charset="utf-8" />
  </head>
  <body>
    <script src="../js/scrape.js"></script> <!-- 加载图片处理逻辑 -->
  </body>
</html>
```

#### （2）scrape.js：iframe的核心逻辑
负责加载图片、用canvas处理图片（比如像素化）、把处理好的结果发出去。
```javascript
// 标识自己：只接收发给“scrape”的消息，避免混乱
const ME = "scrape";

// 1. 图片处理函数：把图片转成大像素块（像素化效果）
const deRezz = (img, canvas) => {
  const chunkSize = 20; // 像素块的大小（值越大，像素越粗）
  const context = canvas.getContext("2d"); // 获取canvas绘图上下文
  context.imageSmoothingEnabled = false; // 关闭图片平滑，保证像素化效果
  context.drawImage(img, 0, 0, canvas.width, canvas.height); // 把图片画到canvas上
  
  // 把canvas里的图片转成像素数据，再遍历画成大色块
  const imageData = context.getImageData(0, 0, canvas.width, canvas.height).data;
  for (let row = 0; row < canvas.height; row += chunkSize) {
    for (let col = 0; col < canvas.width; col += chunkSize) {
      // 取每个像素块的第一个像素颜色，作为整个块的颜色
      const pixel = (row * canvas.width + col) * 4;
      const color = "#" + 
        ("00" + imageData[pixel].toString(16)).substr(-2) + // 红色通道
        ("00" + imageData[pixel+1].toString(16)).substr(-2) + // 绿色通道
        ("00" + imageData[pixel+2].toString(16)).substr(-2); // 蓝色通道
      context.fillStyle = color;
      context.fillRect(col, row, chunkSize, chunkSize); // 画大色块
    }
  }
};

// 2. 命令集合：处理来自background的指令
const cmd = {
  // 接收“渲染图片”的指令：加载原图→用canvas处理→发回结果
  render: (message) => {
    const img = new Image(); // 创建img元素（iframe里有document，所以能创建）
    img.onload = () => {
      // 创建canvas，设置和图片一样的尺寸
      const canvas = document.createElement("CANVAS");
      canvas.height = img.naturalHeight;
      canvas.width = img.naturalWidth;
      
      deRezz(img, canvas); // 处理图片（像素化）
      const newImageSrc = canvas.toDataURL("image/png"); // 把canvas转成Data URI（图片字符串）
      
      // 把处理好的结果发给background
      chrome.runtime.sendMessage({
        cmd: "handleImageData", // 指令名：处理图片数据
        args: {
          oldImageSrc: message.args.oldImageSrc, // 原图URL（用来找要替换的图片）
          newImageSrc: newImageSrc // 处理后的图片Data URI
        }
      }, () => {
        // 结果发完后，告诉background：关闭这个iframe（避免占用资源）
        chrome.runtime.sendMessage({
          to: "logic",
          cmd: "closeOverlay",
          args: { id: message.args.id } // iframe的ID，用来找到并删除它
        });
      });
    };
    img.src = message.args.oldImageSrc; // 加载原图
  }
};

// 3. 监听来自background的消息
chrome.runtime.onMessage.addListener((message) => {
  // 只处理发给“scrape”的消息
  if (message.to === ME && message.cmd && typeof cmd[message.cmd] === "function") {
    cmd[message.cmd](message);
  }
});
```


### 3. 业务逻辑文件：logic.js
负责3件事：打开iframe、关闭iframe、用处理好的图片替换网页上的原图。
```javascript
// 标识自己：只接收发给“logic”的消息
const ME = "logic";

// 命令集合：处理来自background的指令
const cmd = {
  // 1. 替换原图：用处理后的Data URI替换网页上的原图
  renderAlteredImage: (message) => {
    // 遍历网页上所有图片，找到和“原图URL”匹配的图片
    Array.from(document.getElementsByTagName("IMG")).forEach(img => {
      if (img.src === message.args.oldImageSrc) {
        img.src = message.args.newImageSrc; // 替换图片地址
      }
    });
  },
  
  // 2. 打开iframe：创建一个隐藏的iframe（避免影响网页显示）
  openOverlay: (message) => {
    // 只在顶层页面打开iframe（不在网页里的子iframe中打开）
    if (window.self === window.top) {
      const overlay = document.createElement("IFRAME");
      overlay.id = message.args.id; // 给iframe设唯一ID，方便后续关闭
      
      // 隐藏iframe：设成1x1像素，放在页面外
      overlay.height = overlay.width = "1";
      overlay.style.position = "absolute";
      overlay.style.left = overlay.style.top = "-100px";
      
      // iframe加载完成后，告诉它“开始处理图片”
      overlay.onload = () => {
        chrome.runtime.sendMessage({
          to: message.args.overlay, // 发给iframe（scrape）
          cmd: "render", // 指令：渲染图片
          args: message.args // 传原图URL、iframe ID等参数
        });
      };
      
      // 加载iframe页面（从扩展里获取地址）
      overlay.src = chrome.runtime.getURL(`/html/${message.args.overlay}.html`);
      document.body.appendChild(overlay); // 把iframe加到网页里
    }
  },
  
  // 3. 关闭iframe：根据ID找到并删除iframe
  closeOverlay: (message) => {
    if (window.self === window.top) {
      const overlay = document.getElementById(message.args.id);
      if (overlay) overlay.parentNode.removeChild(overlay);
    }
  }
};

// 监听来自background的消息
chrome.runtime.onMessage.addListener((message) => {
  if (message.to === ME && message.cmd && typeof cmd[message.cmd] === "function") {
    cmd[message.cmd](message);
  }
});
```


### 4. 消息转发文件：background.js
V3的background很简单，主要负责“转发消息”——把iframe、logic.js之间的消息传对地方，同时处理“添加右键菜单”“执行逻辑”的基础指令。
```javascript
// 标识自己
const ME = "background";

// 命令集合：处理基础指令
const cmd = {
  // 1. 添加右键菜单：右键图片时显示“V3 Test”菜单
  addMenu: () => {
    chrome.contextMenus.removeAll(); // 先删除旧菜单，避免重复
    chrome.contextMenus.create({
      id: "TestV3",
      title: "V3 Test", // 菜单名称
      contexts: ["image"], // 只在图片上显示菜单
      onclick: (event) => {
        // 点击菜单后，先找到当前活跃的标签页
        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
          const tabId = tabs[0].id;
          // 生成唯一的iframe ID（避免多个iframe冲突）
          const overlayId = `overlay_${Date.now()}`;
          
          // 告诉logic.js：打开iframe，开始处理图片
          chrome.tabs.sendMessage(tabId, {
            to: "logic",
            cmd: "openOverlay",
            args: {
              id: overlayId,
              overlay: "scrape", // 要打开的iframe名称（scrape）
              oldImageSrc: event.srcUrl // 右键的原图URL
            }
          });
        });
      }
    });
  },
  
  // 2. 执行逻辑：加载logic.js到当前网页
  runLogic: (_, sender) => {
    chrome.scripting.executeScript({
      target: { tabId: sender.tab.id },
      files: ["js/logic.js"]
    });
  },
  
  // 3. 处理图片数据：把iframe发来的结果转给logic.js
  handleImageData: (request, sender) => {
    chrome.tabs.sendMessage(sender.tab.id, {
      to: "logic",
      cmd: "renderAlteredImage", // 指令：替换原图
      args: request.args // 传处理后的图片数据
    });
  }
};

// 监听所有消息，负责转发或执行指令
chrome.runtime.onMessage.addListener((request, sender) => {
  if (sender.tab?.id) { // 确保消息来自某个标签页
    if (request.cmd) {
      // 如果消息有“接收者”（比如to: "logic"），就转发过去
      if (request.to && request.to !== ME) {
        chrome.tabs.sendMessage(sender.tab.id, request);
      } 
      // 没有接收者，就自己执行指令（比如addMenu、runLogic）
      else if (typeof cmd[request.cmd] === "function") {
        cmd[request.cmd](request, sender);
      }
    }
  }
});
```


## 四、V3使用步骤
1. 安装扩展：打开Chrome的`chrome://extensions/`页面，开启“开发者模式”，把V3文件夹（ep_006/v3/）拖进去；
2. 找测试页面：打开一个有图片的网页，比如Google图片搜索“dog”（看狗狗图片还能放松）；
3. 测试功能：右键任意一张图片，点击“V3 Test”菜单；
4. 看效果：点击后，图片会立刻变成像素化效果（大色块）。


## 五、V3当前状态
目前V3的方案是“ workaround ”（临时解决办法），因为`fetch` API的跨域问题还没被Chrome官方解决。从Chromium的社区讨论来看，这个问题存在一段时间了，暂时没法确定什么时候能修复，但当前的iframe方案能正常工作。